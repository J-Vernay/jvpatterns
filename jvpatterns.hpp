/*** jvpatterns.hpp by Julien Vernay 2021 ( jvernay.fr ) ***
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef JVERNAY_PATTERNS
#define JVERNAY_PATTERNS

#include <type_traits>
#include <utility>
#include <algorithm>
#include <tuple>
#include <string_view>
#include <optional>

namespace jvpatterns {

#pragma region SUMMARY
    // Result of a match test.
    // Contains an iterator to the end of the match, or empty if no match.
    using std::optional;

    // Utility function.
    template<typename T>
    std::optional<T> make_optional_if(bool condition, T const& value) {
        if (condition) return value;
        else return {};
    }

    // Every pattern `T` must inherit from `pattern_base<T>`.
    // This way, every pattern provides the same utility methods.
    // See also the Curiously Recurring Template Pattern (CRTP).
    // Additionally, for `T` a pattern that operates on a range whose iterators are `FwdIt`,
    // `T` must be callable (via `T::operator()`) with the following signature:
    //     optional<FwdIt> T::operator()(FwdIt it, FwdIt end, SubmatchVisitor&& visitor) const;
    // Where `SubmatchVisitor` is a function object which can be called to report
    // a submatch. To report that `[it2, end2[` is a submatch for `subpattern`,
    // you have to call `visitor(subpattern, it2, end2)`.
    // NOTE: conceptually, a pattern is constant. So `operator()` must be const-qualified.
    //
    // Defines the following methods:
    //     operator[](n)    -> repetition{*this, n}
    //     repeat(min, max) -> repetition{*this, min, max}
    //     tag(value)       -> tagged_pattern{*this, value}
    //     get_tag()        -> void    // overriden by tagged_pattern
    // Can be used with operators + and | :
    //     p1 + p2 + p3 <=> sequence{p1, p2, p3}
    //     p1 | p2`| p3 <=> alternative{p1, p2, p3}
    template<typename Derived>
    struct pattern_base;

    // "Meta" pattern that overrides "get_tag()", allowing a pattern to be tagged.
    // It will then be easier to find it with a SubmatchVisitor.
    template<typename Pattern, typename Tag>
    class tagged_pattern;

    // Type trait to check if it is a pattern.
    template<typename T>
    using is_pattern = std::is_base_of<pattern_base<T>, T>;
    template<typename T>
    constexpr bool is_pattern_v = is_pattern<T>::value;

    // Helper function to check if a pattern is matched.
    // `visitor` is called with the signature `(Pattern const& pattern, FwdIt begin, FwdIt end)`
    // for every match and submatch that suceeded, even if the global pattern did not match.
    // In particular, if the global pattern matches, `visitor` will be called for the global pattern.
    // `match` can be customized with ADL, like std::swap.
    template<typename Pattern, typename FwdIt, typename SubmatchVisitor>
    constexpr optional<FwdIt> match(Pattern const& pattern, FwdIt it, FwdIt end, SubmatchVisitor&& visitor);
    template<typename Pattern, typename FwdIt>
    constexpr optional<FwdIt> match(Pattern const& pattern, FwdIt it, FwdIt end);

    // Pattern to match sequentially all the elements of a range.
    // The range is stored by copy. If this is not wanted, you can first cast 
    // the range to `string_view`, `span<...>`, `ranges::subrange<...>`, etc.
    // Specialization with character arrays (`char[]`, `char16_t[]`, etc) are disallowed
    // to prevent surprising behaviour with literals (null terminator would be part of the pattern).
    // So you must wrap your character array in a `std::string_view` or a `std::span`.
    template<typename Range>
    class equal;
    template<typename Range>
    equal(Range)->equal<Range>;

    // Literal operators for ease of use, i.e. "SomeSequence"_p
    constexpr equal<std::basic_string_view<char>>     operator""_p(char const* p, std::size_t n);
    constexpr equal<std::basic_string_view<wchar_t>>  operator""_p(wchar_t const* p, std::size_t n);
    constexpr equal<std::basic_string_view<char16_t>> operator""_p(char16_t const* p, std::size_t n);
    constexpr equal<std::basic_string_view<char32_t>> operator""_p(char32_t const* p, std::size_t n);
#ifdef __cpp_char8_t
    constexpr equal<std::basic_string_view<char8_t>>  operator""_p(char8_t const* p, std::size_t n);
#endif


    // Pattern to match any element from a range.
    // The range is stored by copy. If this is not wanted, you can first cast 
    // the range to `string_view`, `span<...>`, `ranges::subrange<...>`, etc.
    // Specialization with character arrays (`char[]`, `char16_t[]`, etc) are disallowed
    // to prevent surprising behaviour with literals (null terminator would be part of the pattern).
    // So you must wrap your character array in a `std::string_view` or a `std::span`.
    template<typename Range>
    class any_of;
    template<typename Range>
    any_of(Range)->any_of<Range>;

    // Pattern to match any element that is not in a range.
    // The range is stored by copy. If this is not wanted, you can first cast 
    // the range to `string_view`, `span<...>`, `ranges::subrange<...>`, etc.
    // Specialization with character arrays (`char[]`, `char16_t[]`, etc) are disallowed
    // to prevent surprising behaviour with literals (null terminator would be part of the pattern).
    // So you must wrap your character array in a `std::string_view` or a `std::span`.
    template<typename Range>
    class none_of;
    template<typename Range>
    none_of(Range)->none_of<Range>;

    // Pattern using a predicate to check matches.
    // The predicate must have the signature (FwdIt begin, FwdIt end) -> optional<FwdIt>
    template<typename Func>
    class predicate;
    template<typename Func>
    predicate(Func)->predicate<Func>;

    // Pattern using a predicate to check only the first element.
    // The predicate must have the signature(ValueType value) -> bool
    template<typename Func>
    class predicate_elem;
    template<typename Func>
    predicate_elem(Func)->predicate_elem<Func>;

    // "Meta" pattern that matches any content until the subpattern matches.
    // If end of input is reached, this pattern is considered unmatched.
    // You can make the "until" optional (so that end of input is considered OK)
    // with `until{...}.repeat{0,1}`.
    // NOTE: the subpattern match is not included in this pattern's match:
    // `until{";"_p}` will not include `;` in its match.
    template<typename Pattern>
    class until;
    template<typename Pattern>
    until(Pattern, ...)->until<Pattern>;

    // "Meta" pattern that matches a sequence of patterns.
    // operator+ will merge Patterns into sequence<Patterns>.
    template<typename...Patterns>
    class sequence;
    template<typename...Patterns>
    sequence(Patterns...)->sequence<Patterns...>;

    // "Meta" pattern that matches any pattern.
    // Patterns are tested in order until one matches,
    // so `alternative{"hello"_p, "helloWorld"_p}` will never match the `"helloWorld"_p` alternative. 
    // operator| will merge Patterns into sequence<Patterns>.
    template<typename...Patterns>
    class alternative;
    template<typename...Patterns>
    alternative(Patterns...)->alternative<Patterns...>;

    template<typename Pattern>
    class repetition;
    template<typename Pattern>
    repetition(Pattern,...)->repetition<Pattern>;

#pragma endregion

#pragma region IMPLEMENTATION
    
    template<typename Pattern, typename FwdIt, typename SubmatchVisitor>
    constexpr optional<FwdIt> match(Pattern const& pattern, FwdIt it, FwdIt end, SubmatchVisitor&& visitor) {
        static_assert(std::is_base_of_v<pattern_base<Pattern>, Pattern>, "First argument of jvpatterns::match() is not a Pattern.");
        static_assert(std::is_invocable_r_v < optional<FwdIt>, Pattern, FwdIt, FwdIt, SubmatchVisitor>, "This Pattern does not support the provided iterators or visitor.");
        auto result = pattern(it, end, visitor);
        if (result)
            visitor(pattern, it, *result);
        return result;
    }
    template<typename Pattern, typename FwdIt>
    constexpr optional<FwdIt> match(Pattern const& pattern, FwdIt it, FwdIt end) {
        return match(pattern, it, end, [](auto&&...) {});
    }
    namespace details {
        // Utility function to share range holding logic for equal<>, any_of<> and none_of<>
        template<typename Range>
        struct _range_holder {
            template<typename...Args>
            constexpr _range_holder(Args&&... args) : _range{ std::forward<Args>(args)... } {}

            Range _range;

            template<typename R, typename T>
            static constexpr bool _is_array_of_v = std::is_same_v<std::remove_cv_t<std::remove_extent_t<std::remove_reference_t<R>>>, T>;

            static_assert(std::is_same_v<decltype(std::begin(std::declval<Range>())), decltype(std::end(std::declval<Range>()))>,
                "The 'Range' template parameter of 'jvpatterns::equal' is not a range! Cannot call std::begin(range) or std::end(range).");

            // Preventing hidden error in equal{"my_pattern"}, because null character would make surprising behaviour.
            static_assert(!_is_array_of_v<Range, char>,
                "Ambiguous behaviour: do you want to include the final char (potentially null terminator)?\n"
                "Explicit intention with equal<string_view>{...} if final char must be removed, else equal<span<const char>>{...}");
            static_assert(!_is_array_of_v<Range, wchar_t>,
                "Ambiguous behaviour: do you want to include the final wchar_t (potentially null terminator)?\n"
                "Explicit intention with equal<wstring_view>{...} if final char must be removed, else equal<span<const wchar_t>>{...}");
            static_assert(!_is_array_of_v<Range, char16_t>,
                "Ambiguous behaviour: do you want to include the final char16_t (potentially null terminator)?\n"
                "Explicit intention with equal<u16string_view>{...} if final char must be removed, else equal<span<const char16_t>>{...}");
            static_assert(!_is_array_of_v<Range, char32_t>,
                "Ambiguous behaviour: do you want to include the final char32_t (potentially null terminator)?\n"
                "Explicit intention with equal<u32string_view>{...} if final char must be removed, else equal<span<const char32_t>>{...}");
#ifdef __cpp_char8_t
            static_assert(!_is_array_of_v<Range, char8_t>,
                "Ambiguous behaviour: do you want to include the final char8_t (potentially null terminator)?\n"
                "Explicit intention with equal<u8string_view>{...} if final char must be removed, else equal<span<const char8_t>>{...}");
#endif
        };
    }

    template<typename Derived>
    struct pattern_base {
        // This will provoke a readable error (hopefully) if `Derived` does not support these types.
        template<typename FwdIt, typename SubmatchVisitor>
        constexpr void operator()(FwdIt, FwdIt, SubmatchVisitor&&) const {
            // using sizeof() == 0, so it is evaluated to 'false' at instantiation time. 
            static_assert(0 == sizeof(FwdIt*), "This pattern does not support this iterator type or visitor.");
        }

        constexpr repetition<Derived> operator[](std::size_t n) const { return repeat(n,n); }
        constexpr repetition<Derived> repeat(std::size_t min, std::size_t max) const {
            return { static_cast<Derived const&>(*this), min, max };
        }

        template<typename Tag>
        constexpr tagged_pattern<Derived, Tag> tag(Tag const& tag = Tag{}) const {
            return { static_cast<Derived const&>(*this), tag };
        }

        using tag_type = void;
        constexpr void get_tag() const {}
    };

    template<typename Pattern, typename Tag>
    class tagged_pattern : public pattern_base<tagged_pattern<Pattern, Tag>> {
        static_assert(is_pattern_v<Pattern>, "Argument of tagged_pattern<...> is not a Pattern.");
    public:
        constexpr tagged_pattern(Pattern const& pattern, Tag const& tag) : _pattern{ pattern }, _tag{ tag } {}

        template<typename FwdIt, typename SubmatchNotifier>
        constexpr optional<FwdIt> operator()(FwdIt begin, FwdIt end, SubmatchNotifier&& submatch_notifier) const {
            return match(_pattern, begin, end, submatch_notifier);
        }

        using tag_type = Tag;
        constexpr Tag const& get_tag() const { return _tag; }
    private:
        Pattern _pattern;
        Tag _tag;
    };

#pragma region TERMINALS
    template<typename Func>
    class predicate : public pattern_base<predicate<Func>> {
    public:
        constexpr predicate(Func const& func) : _func{ func } {}

        template<typename FwdIt, typename SubmatchVisitor>
        constexpr optional<FwdIt> operator()(FwdIt begin, FwdIt end, SubmatchVisitor&&) const {
            return _func(begin, end);
        }

    private:
        Func _func;
    };

    template<typename Func>
    class predicate_elem : public pattern_base<predicate_elem<Func>> {
    public:
        constexpr predicate_elem(Func const& func) : _func{ func } {}

        template<typename FwdIt, typename SubmatchVisitor>
        constexpr optional<FwdIt> operator()(FwdIt begin, FwdIt end, SubmatchVisitor&&) const {
            if (begin != end && _func(*begin)) return ++begin;
            else return {};
        }

    private:
        Func _func;
    };

    template<typename Range>
    class equal : public pattern_base<equal<Range>>, private details::_range_holder<Range> {
    public:
        // inheriting constructors, which only forward to Range constructors
        using details::_range_holder<Range>::_range_holder;
        
        template<typename FwdIt, typename SubmatchVisitor>
        constexpr optional<FwdIt> operator()(FwdIt begin, FwdIt end, SubmatchVisitor&&) const {
            static_assert(std::is_convertible_v<decltype(*begin == *std::begin(this->_range)), bool>,
                "Elements from range of 'jvpatterns::equal' cannot be compared to elements from given iterators.");
            auto begin2 = std::begin(this->_range), end2 = std::end(this->_range);
            auto [it, it2] = std::mismatch(begin, end, begin2, end2);
            return make_optional_if(it2 == end2, it);
        }
    };

    constexpr equal<std::basic_string_view<char>>     operator""_p(char const* p, std::size_t n) { return { p, n }; }
    constexpr equal<std::basic_string_view<wchar_t>>  operator""_p(wchar_t const* p, std::size_t n) { return { p, n }; }
    constexpr equal<std::basic_string_view<char16_t>> operator""_p(char16_t const* p, std::size_t n) { return { p, n }; }
    constexpr equal<std::basic_string_view<char32_t>> operator""_p(char32_t const* p, std::size_t n) { return { p, n }; }
#ifdef __cpp_char8_t
    constexpr equal<std::basic_string_view<char8_t>>  operator""_p(char8_t const* p, std::size_t n) { return { p, n }; }
#endif

    template<typename Range>
    class any_of : public pattern_base<any_of<Range>>, private details::_range_holder<Range> {
    public:
        // inheriting constructors, which only forward to Range constructors
        using details::_range_holder<Range>::_range_holder;

        template<typename FwdIt, typename SubmatchVisitor>
        constexpr optional<FwdIt> operator()(FwdIt begin, FwdIt end, SubmatchVisitor&&) const {
            static_assert(std::is_convertible_v<decltype(*begin == *std::begin(this->_range)), bool>,
                "Elements from range of 'jvpatterns::equal' cannot be compared to elements from given iterators.");
            if (begin == end) return {};
            auto begin2 = std::begin(this->_range), end2 = std::end(this->_range);
            auto it2 = std::find(begin2, end2, *begin);
            return make_optional_if(it2 != end2, ++begin);
        }
    };

    template<typename Range>
    class none_of : public pattern_base<none_of<Range>>, private details::_range_holder<Range> {
    public:
        // inheriting constructors, which only forward to Range constructors
        using details::_range_holder<Range>::_range_holder;


        template<typename FwdIt, typename SubmatchVisitor>
        constexpr optional<FwdIt> operator()(FwdIt begin, FwdIt end, SubmatchVisitor&&) const {
            static_assert(std::is_convertible_v<decltype(*begin == *std::begin(this->_range)), bool>,
                "Elements from range of 'jvpatterns::equal' cannot be compared to elements from given iterators.");
            if (begin == end) return {};
            auto begin2 = std::begin(this->_range), end2 = std::end(this->_range);
            auto it2 = std::find(begin2, end2, *begin);
            return make_optional_if(it2 == end2, ++begin);
        }
    };
#pragma endregion

#pragma region SEQUENCE
    template<typename...Patterns>
    class sequence : public pattern_base<sequence<Patterns...>> {
        static_assert((is_pattern_v<Patterns> && ...), "sequence<...> must only contain patterns.");
        using I_sequence = std::make_index_sequence<sizeof...(Patterns)>;
    public:
        constexpr sequence(Patterns const&... patterns) : _patterns{ patterns... } {}

        template<typename FwdIt, typename SubmatchVisitor, std::size_t...I>
        constexpr optional<FwdIt> operator()(FwdIt begin, FwdIt end, SubmatchVisitor&& visitor) const {
            return _impl(begin, end, visitor, I_sequence{});
        }

        template<typename Pattern2, size_t...I>
        static constexpr sequence<Patterns..., Pattern2> _impl_add(sequence<Patterns...> const& p1, Pattern2 const& p2, std::index_sequence<I...>) {
            return { std::get<I>(p1._patterns)..., p2 };
        }
        template<typename Pattern1, size_t...I>
        static constexpr sequence<Patterns..., Pattern1> _impl_add(Pattern1 const& p1, sequence<Patterns...> const& p2, std::index_sequence<I...>) {
            return { p1, std::get<I>(p1._patterns)... };
        }
        template<typename...Patterns2, size_t...I1, size_t...I2>
        static constexpr sequence<Patterns..., Patterns2...> _impl_add(sequence<Patterns...> const& p1, sequence<Patterns2...> const& p2,
            std::index_sequence<I1...>, std::index_sequence<I2...>) {
            return { std::get<I1>(p1._patterns)..., std::get<I2>(p2._patterns)... };
        }

    private:
        template<typename...T>
        friend class sequence;

        template<typename FwdIt, typename SubmatchVisitor, std::size_t...I>
        constexpr optional<FwdIt> _impl(FwdIt begin, FwdIt end, SubmatchVisitor&& visitor, std::index_sequence<I...>) const {
            FwdIt current = begin;
            bool sequence_matched = ([&]() -> bool {
                auto const& pattern = std::get<I>(_patterns);
                auto result = match(pattern, current, end, visitor);
                if (result) current = *result;
                return (bool)result;
                }() && ...);
            return make_optional_if(sequence_matched, current);
        }

        template<typename P2, std::size_t...I>
        static constexpr sequence<Patterns..., P2> _add_impl(sequence const& p1, P2 const& p2, std::index_sequence<I...>) {
            return { std::get<I>(p1)..., p2 };
        }
        template<typename P1, std::size_t...I>
        static constexpr sequence<P1, Patterns...> _add_impl(P1 const& p1, sequence const& p2, std::index_sequence<I...>) {
            return { p1, std::get<I>(p2)... };
        }
        template<typename...P1, std::size_t...I>
        static constexpr sequence<P1..., Patterns...> _add_impl(sequence<P1...> const& p1, sequence const& p2, std::index_sequence<I...>) {
            return { p1, std::get<I>(p2)... };
        }

        std::tuple<Patterns...> _patterns;
    };

    // operator+
    template<typename P1, typename P2, typename = std::enable_if_t<is_pattern_v<P1>&& is_pattern_v<P2>>>
    constexpr sequence<P1, P2> operator+(P1 const& p1, P2 const& p2) {
        return { p1, p2 };
    }
    template<typename...Patterns, typename P2, typename = std::enable_if_t<is_pattern_v<P2>>>
    constexpr sequence<Patterns..., P2> operator+(sequence<Patterns...> const& p1, P2 const& p2) {
        return p1._impl_add(p1, p2, std::make_index_sequence<sizeof...(Patterns)>{});
    }
    template<typename P1, typename...Patterns, typename = std::enable_if_t<is_pattern_v<P1>>>
    constexpr sequence<P1, Patterns...> operator+(P1 const& p1, sequence<Patterns...> const& p2) {
        return p2._impl_add(p1, p2, std::make_index_sequence<sizeof...(Patterns)>{});
    }
    template<typename...Patterns1, typename...Patterns2>
    constexpr sequence<Patterns1..., Patterns2...> operator+(sequence<Patterns1...> const& p1, sequence<Patterns2...> const& p2) {
        return p1._impl_add(p1, p2, std::make_index_sequence<sizeof...(Patterns1)>{}, std::make_index_sequence<sizeof...(Patterns2)>{});
    }
#pragma endregion

#pragma region ALTERNATIVE
    template<typename...Patterns>
    class alternative : public pattern_base<alternative<Patterns...>> {
        static_assert((is_pattern_v<Patterns> && ...), "sequence<...> must only contain patterns.");
        using I_sequence = std::make_index_sequence<sizeof...(Patterns)>;
    public:
        constexpr alternative(Patterns const&... patterns) : _patterns{ patterns... } {}

        template<typename FwdIt, typename SubmatchVisitor, std::size_t...I>
        constexpr optional<FwdIt> operator()(FwdIt begin, FwdIt end, SubmatchVisitor&& visitor) const {
            return _impl(begin, end, visitor, I_sequence{});
        }

        template<typename Pattern2, size_t...I>
        static constexpr alternative<Patterns..., Pattern2> _impl_or(alternative<Patterns...> const& p1, Pattern2 const& p2, std::index_sequence<I...>) {
            return { std::get<I>(p1._patterns)..., p2 };
        }
        template<typename Pattern1, size_t...I>
        static constexpr alternative<Patterns..., Pattern1> _impl_or(Pattern1 const& p1, alternative<Patterns...> const& p2, std::index_sequence<I...>) {
            return { p1, std::get<I>(p1._patterns)... };
        }
        template<typename...Patterns2, size_t...I1, size_t...I2>
        static constexpr alternative<Patterns..., Patterns2...> _impl_or(alternative<Patterns...> const& p1, alternative<Patterns2...> const& p2,
            std::index_sequence<I1...>, std::index_sequence<I2...>) {
            return { std::get<I1>(p1._patterns)..., std::get<I2>(p2._patterns)... };
        }
    private:
        template<typename FwdIt, typename SubmatchVisitor, std::size_t...I>
        constexpr optional<FwdIt> _impl(FwdIt begin, FwdIt end, SubmatchVisitor&& visitor, std::index_sequence<I...>) const {
            optional<FwdIt> result;
            (void) ([&]() -> bool {
                auto const& pattern = std::get<I>(_patterns);
                result = match(pattern, begin, end, visitor);
                return (bool)result;
                }() || ...);
            return result;
        }

        std::tuple<Patterns...> _patterns;
    };

    // operator|
    template<typename P1, typename P2, typename = std::enable_if_t<is_pattern_v<P1>&& is_pattern_v<P2>>>
    constexpr alternative<P1, P2> operator|(P1 const& p1, P2 const& p2) {
        return { p1, p2 };
    }
    template<typename...Patterns, typename P2, typename = std::enable_if_t<is_pattern_v<P2>>>
    constexpr alternative<Patterns..., P2> operator|(alternative<Patterns...> const& p1, P2 const& p2) {
        return p1._impl_or(p1, p2, std::make_index_sequence<sizeof...(Patterns)>{});
    }
    template<typename P1, typename...Patterns, typename = std::enable_if_t<is_pattern_v<P1>>>
    constexpr alternative<P1, Patterns...> operator|(P1 const& p1, alternative<Patterns...> const& p2) {
        return p2._impl_or(p1, p2, std::make_index_sequence<sizeof...(Patterns)>{});
    }
    template<typename...Patterns1, typename...Patterns2>
    constexpr alternative<Patterns1..., Patterns2...> operator|(alternative<Patterns1...> const& p1, alternative<Patterns2...> const& p2) {
        return p1._impl_or(p1, p2, std::make_index_sequence<sizeof...(Patterns1)>{}, std::make_index_sequence<sizeof...(Patterns2)>{});
    }
#pragma endregion

#pragma region REPETITION
    template<typename Pattern>
    class repetition : public pattern_base<repetition<Pattern>> {
        static_assert(is_pattern_v<Pattern>, "Argument of repetition<...> is not a Pattern.");
    public:
        constexpr repetition(Pattern const& pattern, size_t min, size_t max) : _pattern{ pattern }, _min{ min }, _max{ max } {}
        constexpr repetition(Pattern const& pattern, size_t n) : _pattern{ pattern }, _min{ n }, _max{ n } {}

        template<typename FwdIt, typename SubmatchVisitor>
        constexpr optional<FwdIt> operator()(FwdIt begin, FwdIt end, SubmatchVisitor&& submatch_visitor) const {
            FwdIt it = begin;
            size_t i = 0;
            for (; i < _max; ++i) {
                auto result = match(_pattern, it, end, submatch_visitor);
                if (result) it = *result;
                else break;
            }
            return make_optional_if(i >= _min, it);
        } 

    private:
        Pattern _pattern;
        size_t _min, _max;
    };
#pragma endregion

#pragma region UNTIL
    template<typename Pattern>
    class until : public pattern_base<until<Pattern>> {
        static_assert(is_pattern_v<Pattern>, "Argument of until<...> is not a Pattern.");
    public:
        constexpr until(Pattern const& pattern) : _pattern{ pattern } {}

        template<typename FwdIt, typename SubmatchVisitor>
        constexpr optional<FwdIt> operator()(FwdIt begin, FwdIt end, SubmatchVisitor&& submatch_visitor) const {

            for (FwdIt it = begin; it != end; ++it) {
                auto result = match(_pattern, it, end, submatch_visitor);
                if (result) return it;
            }
            return {};
        }

    private:
        Pattern _pattern;
    };
#pragma endregion

    
#pragma endregion
}

#endif


